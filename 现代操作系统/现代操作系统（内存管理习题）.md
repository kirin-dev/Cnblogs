[TOC](内存管理习题)

参考：`https://www.cnblogs.com/jason1999/p/12014291.html`

# 选择题

DCCBC ADBCC

CBCDB CDADC

C

# 计算题(选择)

 CAAB DCCBD

ABDBB CCDAB

A

# 计算题(填空)

> 1

- 16KB

- 01535180H

- 03511036H

> 2

- 4KB

- 4MB

- LA>>22&3FFH

- LA>>12&3FFH

- 16KB

- 00200020H

- 00200040H

- 00900H

- 00901H

- 00901000H

# 计算题(简答)

> 1

- $4KB = 2^{12}B$
2->1->2
虚拟地址2362H：$10 + 100 + 100 = 210ns$
虚拟地址1565H：$10 + 100 + 10^8 + 10 + 100 = 220 + 10^8ns$
虚拟地址25A5H：$10 + 100 = 110ns$

- 101565H（由LRU，页面0最近最少使用，被淘汰）

> 2

- 01111/10110/10001/00100/01011/00101
其中00100最小，淘汰Page3

- 老化算法只记录最近若干次页面使用情况，更早的使用情况会丢失。并且老化算法没有记录在一个时间周期内页面的使用频度和时间等，所以只是LRU的一个近似实现。

> 3

- $64KB = 2^{16}B$
$1KB = 2^{10}$
17CAH:0001|0111|C|AH
页号：000101=5

- 由LRU，页面0最近最少使用，被淘汰，因此页号5对应的页框号为7=000111
17CAH对应物理地址：1FCAH

> 4

- $4KB = 2^{12}B$
$4GB = 2^{32}B$
$64 - 12 = 52位$
$4KB/4B = 10个$
$⌈52/10⌉ = 6$
所以需要六级页表

- $2^{32-12}B = 2^{20}B = 1MB$
$8 * 1MB = 8MB$
系统维护一张倒排列表
解决办法：使用TLB。

# 简答题

> 1.解决了共享困难的问题、程序大小受限的问题。带来了内存利用率低(因为产生外部碎片)的问题。

> 2.是，用分段管理逻辑地址，用分页管理物理地址。

> 3.需要在内存中维护一个所有页面的链表，每次访问内存都需要更新整个链表。可行的取代方案：老化算法。

> 4.分段式产生外部碎片，分页式会造成系统抖动。段页式用分段管理逻辑地址，用分页管理物理地址。实现过程及其麻烦。

> 5.固定分区管理中分区的大小是固定的，容纳作业的大小受限，空闲区对固定分区没有意义，也就无法按照尺寸对空闲区排序。请求式分段技术：如果要访问的**分段**不在内存中，则通过调段功能将其调入，同时还可以通过置换功能将暂时不用的分段换出到外存，以便腾出内存空间。交换技术：把被阻塞的**进程**换出内存。覆盖技术：将程序划分为若干个功能上相对独立的程序段，按照程序逻辑结构让那些不需要同时执行的程序段共享同一块内存区。

> 6.页表的在/不在位为0。OPT算法。需要在内存中维护一个所有页面的链表，每次访问内存都需要更新整个链表。Belady异常：如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。FIFO算法。

> 7.找出一个不在工作集中的页面并淘汰它，每个表项至少包含两条信息：上次使用该页面的近似时间和R位。

> 8.消除系统抖动现象。结合了分段与分页的优点并消除了大部分缺点。

> 9.cache能够加快存取速度。主存与CPU之间进行数据交换时需要用到。

> 10.节省空间。从虚拟地址到物理地址的转换变得很困难。使用TLB。

> 11.不同点：交换的对象一个是进程一个是段。相同点：都将不常使用部分的置换出内存。

> 12.老化算法只记录最近若干次页面使用情况，更早的使用情况会丢失。并且老化算法没有记录在一个时间周期内页面的使用频度和时间等，所以只是LRU的一个近似实现。
