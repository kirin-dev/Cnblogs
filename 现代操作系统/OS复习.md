# Exam

大题：

> 进程管理
>
> - 批处理作业调度算法/轮转调度/优先级调度√
> - PV原语√
> - 银行家算法√

## 进程管理

### 概念

多道程序设计(伪并行)

系统调用：fork()、exec()、wait()、exit()。

进程的状态：

![img](https://img2023.cnblogs.com/blog/2975286/202212/2975286-20221201153736099-1808079028.png)

### 进程与线程

- 线程是**调度**的最小单位。
- 进程是**资源分配**的最小单位。

![img](https://img2023.cnblogs.com/blog/2975286/202212/2975286-20221201154607589-2120038322.png)

- 用户级：操作系统调度进程，进程调度线程
- 内核级：操作系统直接调度线程

### 调度

批处理作业调度算法：

- 先来先服务FCFS
- 最短作业优先SJF
- 高相应比优先HRF

重要参数：

![img](https://img2023.cnblogs.com/blog/2975286/202212/2975286-20221201155937757-327204404.png)

轮转调度：

如果在**时间片**结束时，该进程还在运行，则将CPU分配给下一个进程；如果提前结束，则立即进行切换。

优先级调度：

Priority = base + nice + CPU_PENALTY(0~127，0优先级最高，127优先级最低)

### 竞争

临界区：访问临界资源的**代码**

#### 忙等待

连续测试一个变量直到某个值出现为止。

**锁变量**：当进程想要进入临界区时，首先测试锁的值是否为0，如果为0则将其设置为1并进入。

TSL(test and set lock)：

将一个内存字lock读到寄存器中，然后再该内存地址上存一个非零值。(读字和写字不可分割)

```C
enter_region:
    MOVE REGISTER, #1
    XCHG REGISTER, LOCK//交换
    CMP REGISTER, #0
    JNE enter_region
    RET
leave_region:
    MOVE LOCK, #0
    RET
```

#### 睡眠与唤醒

信号量(semaphore)

PV原语(down/up)是原子性的，快速且不能被打断。

信号量**只能被P、V原语操作**，否则倒扣分。

> 锁变量：0表示开，1表示关
>
> 二元信号量：0表示不可用，1表示有一个可用

记录型信号量：变量s+队列(睡觉用)

- positive：表示可用资源个数
- zero：无可用资源，无进程等待
- negative：绝对值表示队列中睡觉(被阻塞)的进程个数

#### 经典IPC问题

见PV练习

- 生产者消费者问题
- 读者写者问题
- 哲学家就餐问题

### 死锁

定义：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。

四个必要条件：

- 互斥
- 不可抢占
- 占有和等待(Hold and wait)（部分拥有，期望更多）
- 环路等待(Circular wait)（循环等待）

处理死锁的策略：

1. 鸵鸟算法

2. 检测与恢复

    - 资源分配有向图
    - 资源分配矩阵
    - 杀死什么样的进程代价最小？

3. 死锁避免

    - 资源轨迹图
    - 安全/不安全状态(必会发生死锁)
    - **银行家算法**(类似于讨债，如何处理资源分配矩阵？安全序列？)

4. 死锁预防

    - 破坏互斥条件：不可行，但可以避免分配不是绝对必需的资源
    - 破坏占有和等待条件：静态分配/动态分配
    - 破坏不可抢占条件：允许进程剥夺使用其他进程占有的资源
    - 破坏环路等待条件：资源有序分配

## 内存管理

碎片：

- 内部碎片：固定分区(进程管理部分)；分页；分段页
- 外部碎片：可变分区(进程管理部分)；分段

![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230316153014183-490473515.png)

### 分区管理

分配内存算法：FF/NF/BF/WF/QF
![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230316155539667-1896770538.png)

### 分页管理

缺页中断：访问的页面没有被映射，对应页表项的“在/不在”位为0

已知虚拟地址(页号+页内偏移)、页表，求物理地址(页框号+页内偏移)？
![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230316163402451-588840008.png)

页表项的结构：高速缓存禁止位/访问位/修改位/保护位/“在/不在”位/页框号

加速分页过程：TLB快表

多级页表：![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230316170749454-730056697.png)
页面大小？页面数量？虚拟地址空间大小？几级页表？

倒排页表：![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230316171253457-639326038.png)
64位，页4KB，RAM4GB，倒排页表仅需$2^{20}$个表项
节省大量空间，但从虚拟地址到物理地址的转换很困难(使用TLB)

页面置换算法：

1. 最优页面置换算法OPT：无法实现(向后找)
2. 最近未使用页面置换算法NRU 两个状态位R/M 00/01/10/11 算法随机地从编号最小的非空类中淘汰一个页面：不是最快但够用
3. 先进先出页面置换算法FIFO 淘汰存在时间最长的页面：存在时间长也可能频繁使用
4. 第二次机会页面置换算法 检查存在时间最长的页面的R位，如果为0，则淘汰，视作新加入的页面：经常移动页面，效率低
5. 时钟页面置换算法：效率高，若淘汰则把指针前移一位
6. 最近最少使用页面置换算法LRU 置换未使用时间最长的页面：理论上可实现，代价高(向前找)
7. 最不常用页面置换算法NFU+老化算法aging 在R位被加进之前将计数器右移一位，将R位加到最左端 淘汰计数器值最小的页面：模拟LRU![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230316173715291-2026827167.png)

缺页率：FIFO>LRU>OPT

系统抖动(thrashing)：因为使用了不恰当的页面置换算法，导致主存和辅存间频繁的页面置换。

### 分段管理

段长度可变，相互独立且一般不相同。

作用：使程序和数据可以被划分为逻辑上独立的地址空间，有助于共享和保护

段页式：分段管理内在逻辑，分页决定存放方式。段号|页号|页内偏移

## 文件管理

inode：![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230316180602686-1883500816.png)

读写一个磁盘块花费时间：

1. 寻道时间 磁盘臂移动到适当的柱面上
2. 旋转延迟 等待适当的扇区旋转到磁头下
3. 实际数据传输时间

磁盘臂调度算法：

1. 先来先服务FCFS
2. 最短寻道优先SSTF 总是处理与磁头距离最近的请求
3. 电梯算法SCAN 保持按一个方向扫描，再反方向
4. C-SCAN 总保持按一个方向扫描(类似环状扫描)

错误处理：用备用扇区替换/避开扇区

## 设备管理

只考选择
