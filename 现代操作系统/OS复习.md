# Exam

大题：

> 进程管理
>
> - 批处理作业调度算法/轮转调度/优先级调度√
> - PV原语√
> - 银行家算法√
>
> 内存管理
>
> - 

## 进程管理

### 概念

多道程序设计(伪并行)

系统调用：fork()、exec()、wait()、exit()。

进程的状态：

![img](https://img2023.cnblogs.com/blog/2975286/202212/2975286-20221201153736099-1808079028.png)

### 进程与线程

- 线程是**调度**的最小单位。
- 进程是**资源分配**的最小单位。

![img](https://img2023.cnblogs.com/blog/2975286/202212/2975286-20221201154607589-2120038322.png)

- 用户级：操作系统调度进程，进程调度线程
- 内核级：操作系统直接调度线程

### 调度

批处理作业调度算法：

- 先来先服务FCFS
- 最短作业优先SJF
- 高相应比优先HRF

重要参数：

![img](https://img2023.cnblogs.com/blog/2975286/202212/2975286-20221201155937757-327204404.png)

轮转调度：

如果在**时间片**结束时，该进程还在运行，则将CPU分配给下一个进程；如果提前结束，则立即进行切换。

优先级调度：

Priority = base + nice + CPU_PENALTY(0~127，0优先级最高，127优先级最低)

### 竞争

临界区：访问临界资源的**代码**

#### 忙等待

连续测试一个变量直到某个值出现为止。

**锁变量**：当进程想要进入临界区时，首先测试锁的值是否为0，如果为0则将其设置为1并进入。

TSL(test and set lock)：

将一个内存字lock读到寄存器中，然后再该内存地址上存一个非零值。(读字和写字不可分割)

```C
enter_region:
    MOVE REGISTER, #1
    XCHG REGISTER, LOCK//交换
    CMP REGISTER, #0
    JNE enter_region
    RET
leave_region:
    MOVE LOCK, #0
    RET
```

#### 睡眠与唤醒

信号量(semaphore)

PV原语(down/up)是原子性的，快速且不能被打断。

信号量**只能被P、V原语操作**，否则倒扣分。

> 锁变量：0表示开，1表示关
>
> 二元信号量：0表示不可用，1表示有一个可用

记录型信号量：变量s+队列(睡觉用)

- positive：表示可用资源个数
- zero：无可用资源，无进程等待
- negative：绝对值表示队列中睡觉(被阻塞)的进程个数

#### 经典IPC问题

见PV练习

- 生产者消费者问题
- 读者写者问题
- 哲学家就餐问题

### 死锁

定义：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。

四个必要条件：

- 互斥
- 不可抢占
- 占有和等待(Hold and wait)（部分拥有，期望更多）
- 环路等待(Circular wait)（循环等待）

处理死锁的策略：

1. 鸵鸟算法

2. 检测与恢复

    - 资源分配有向图
    - 资源分配矩阵
    - 杀死什么样的进程代价最小？

3. 死锁避免

    - 资源轨迹图
    - 安全/不安全状态(必会发生死锁)
    - **银行家算法**(类似于讨债，如何处理资源分配矩阵？安全序列？)

4. 死锁预防

    - 破坏互斥条件：不可行，但可以避免分配不是绝对必需的资源
    - 破坏占有和等待条件：静态分配/动态分配
    - 破坏不可抢占条件：允许进程剥夺使用其他进程占有的资源
    - 破坏环路等待条件：资源有序分配

## 内存管理

碎片：

- 内部碎片：固定分区(进程管理部分)；分页；分段页
- 外部碎片：可变分区(进程管理部分)；分段

系统抖动(thrashing)：因为使用了不恰当的页面置换算法，导致主存和辅存间频繁的页面置换。

段页式：分段管理内在逻辑，分页决定存放方式。

## 文件管理

## 设备管理
