[TOC](进程管理习题)

# 单项选择题

CBCDB BDCDA

BDADC BBDBC

ABADA ADCDD

ADCBC CA

# 简答题

1. 实现用户级线程，此时内核意识不到线程的存在，把它看作一个单线程进程进行管理。

2. exec()；系统调用通常返回一个负值来表明错误，返回0表明成功。

3. 杀死最年轻的进程，因为它恢复到原来状态的代价最小。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020224618668-230451867.png)

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020224628994-969053991.png)
![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020224645437-1919868116.png)

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020224719121-1836157594.png)

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020224725281-952479312.png)
![img](https://img2022.cnblogs.com/blog/2975286/202211/2975286-20221107173415884-74271380.png)

8. 采用动态调整进程优先级的方法。动态降低长时间占用CPU进程的优先级，低优先级的进程的优先级则相对升高，最终得到运行。

9. 可行方法：鸵鸟算法——忽略死锁问题。如何应对：通过杀死最年轻的进程直到不发生死锁来恢复(代价小)。(实际常采用的方法: 1.鸵鸟算法。因为处理死锁成本太高，而死锁出现的频率较低，故可以忽略死锁的发生。 2.Spooling 技术。假脱机技术。为临界资源增加一个等待队列，使其好像可以被共享使用，如打印机。 当死锁发生时，杀死运行时间较短的进程，损失较小，因为容易恢复。)

10. 9个——foo函数中，如果成功fork出一个子线程，则在子线程中fork一个新线程，然后在新线程t上执行函数bar，而bar函数中又fork了一个新线程，此时有4个线程，因此调用bar函数输出了4个hello。bar函数结束后又恢复成2个线程，因此除bar函数之外又输出了2个hello。回到main函数，又多一个主线程，输出3个hello。4 + 2 + 3 = 9个。(依运行方式不同，共打印9次或11次hello。)

# 单选解析

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020180119338-1359821048.png)

C

- 信号量非负时，表示可用资源的个数。

- 信号量为负时，可用资源个数为0，信号量绝对值表示在睡觉队列中（被阻塞）的进程个数。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020180514633-698272572.png)

B

进程的三种基本状态：运行态(running)/就绪态(ready)/阻塞态(blocked)——三种状态都在内存中。

AC均为就绪态；D为挂起态，不在内存中；阻塞态(睡觉)需要等待被唤醒。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020181044766-1382550787.png)

C

A用户级线程切换时不需要内核的支持。

- 进程是拥有资源的独立单位，同一进程下的线程共享进程中的资源。

- (引入线程的系统中)线程是调度和分配的基本单位。（未引入线程则进程是调度和分配的基本单位）

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020182203486-1469282916.png)

D

死锁产生的四个必要条件：

- 互斥
- 不可抢占
- 占有和等待(Hold and wait)（部分拥有，期望更多）
- 环路等待(Circular wait)（循环等待）

死锁预防：

- 破坏互斥条件：不可行，但可以避免分配不是绝对必需的资源
- 破坏占有和等待条件：静态分配/动态分配
- 破坏不可抢占条件：允许进程剥夺使用其他进程占有的资源
- 破坏环路等待条件：资源有序分配

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020183707937-1707737245.png)

B

用户态切换到内核态的三种情况：

- 系统调用
- 异常
- 外围设备的中断

Ⅰ异常；Ⅱ调用math库函数；Ⅲ系统调用。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020183932398-279178517.png)

B

银行家算法是Dijkstra提出的用于避免死锁的调度算法。

安全状态一定无死锁进程，不安全状态不一定有死锁进程，但终将会导致死锁。

破坏四大必要条件属于预防死锁。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020184531034-1205929945.png)

D

A:18(CDBEA-2min);B:20;C:19.2;D:14.

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020191243953-927867287.png)

C

无法修改，没有竞争条件，所以可以在任意时刻共享。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020191530226-1987371646.png)

D

(w - 1) \* n ? m

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020191939576-2115166143.png)

A

时间片轮转雨露均沾，每个轮转中的每个作业都平等地运行一个时间片。

BCD均有优先级，资源可能一直被抢占，容易导致饥饿现象。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020192334593-1027015325.png)

B

(2 + 3 + 4) + 1 = 10

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020192446145-710802572.png)

D

D需在内核态。trap指令负责由用户态转换成为内核态。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020192724076-971891334.png)

A

进程申请读磁盘操作需要先进入阻塞态，等待I/O完成后唤醒其进入就绪态，等待调度。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020193246083-2116770580.png)
![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020193305691-1976249464.png)

D

Allocation Need

212 347

436 100

402 009

204 221

314 110

Available(202)

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020193330813-869067499.png)

C

(40 + 22 + 62 + 17 + 45) / 5 = 37.2

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020194808210-26962273.png)

B

设置优先级的参照规则：

- 系统进程 > 用户进程
- 交互进程(前台进程) > 非交互进程(后台进程)
- I/O进程 > 计算进程

计算进程会占用大量的cpu时间，而I/O大的会占用较少的cpu资源。I/O密集型相当于短作业，优先级更高。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020200043580-1999932517.png)

B

程序状态字(PSW)寄存器用于记录当前处理器的状态和控制指令的执行顺序，并且保留与运行程序相关的各种信息，主要作用是实现程序状态的保护和恢复。所以中断处理程序要将PSW保存，子程序调用在进程内部执行，不会更改PSW。

CD都不保存，A都保存。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020200429558-842779181.png)

D

和题目7一样

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020200756256-1359046966.png)

B

60 + 120 + 40 + 40 = 260

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020201010427-1461166851.png)

C

不能进行调度和切换的情况：

- 在处理中断过程中
- 进程在操作系统内核程序的临界区中
- 其他需要完全屏蔽中断的原子操作过程中

当进程处于临界区时，说明进程正在占用处理机，只要不破坏临界资源的使用规则，是不会影响处理机调度的。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020201408502-610701135.png)

A

和题目3类似

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020201615428-1150020912.png)
![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020201629603-762401868.png)

B

和题目6一样

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020201722646-805644337.png)

A

I缺页中断，被阻塞；Ⅱ题目5已提及；

Ⅲ要读一个文件，首先要用open系统调用打开该文件。open中的参数包括文件的路径名和文件名，而read只需使用open返回的文件描述符，并不使用文件名作为参数。

read要求用户提供三个输入参数：

- 文件描述符fd
- buf缓冲区首址
- 传送的字节数n

read的功能是试图从fd所指示的文件中读入n个字节的数据，并将它们送至由指针buf所指示的缓冲区中。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020202050212-1847429487.png)

D

Allocation Need

323 237

403 133

405 006

204 221

324 100

Available(223)

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020202355780-891240348.png)

A

信号量非负时，表示可用资源的个数。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020202525130-848327695.png)

A

进程同步指两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的消息或信号，当一个进程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号到达才被唤醒。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020202740304-831814817.png)
![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020202748207-565895366.png)

D

死锁的规范定义：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020202924255-519827828.png)

C

书P52 图2-2

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020203049599-1904999664.png)

D

临界区：对共享内存进行访问的程序片段。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020203142599-1078128560.png)

D

Allocation Need

4321 7001

1321 0500

3201 2011

2100 4212

Available(2011)

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020203631242-1345616200.png)
![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020203648699-1745679975.png)

A D C

(2 \* 6 + 4 \* 5 + 2 \* 4 + 12 \* 3 + 8 \* 2 + 6) / 6 = 16.33

(12 \* 6 + 6 \* 5 + 2 \* 4 + 4 \* 3 + 8 \* 2 + 2) / 6 = 23.33

(2 \* 6 + 2 \* 5 + 4 \* 4 + 6 \* 3 + 8 \* 2 + 12) / 6 = 14

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020204827350-886541908.png)

B

2 + 3 + 4 + 4 + 4 = 17

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020205048581-676242038.png)

C

P1P2P3(P4)死锁。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020205436626-574012692.png)

C

同进程下函数的a/两进程的x都不共用地址，所以D不需要互斥执行。

![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020205609847-1232155463.png)
![img](https://img2022.cnblogs.com/blog/2975286/202210/2975286-20221020205623109-1948747536.png)

A

Allocation Need

20 30

25 25

30 20

10 40

Available(15)
