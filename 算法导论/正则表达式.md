# 正则表达式

字符串匹配
<https://www.runoob.com/regexp/regexp-syntax.html>

通过使用正则表达式，可以：

- 测试字符串内的模式。例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。
- 替换文本。可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。
- 基于模式匹配从字符串中提取子字符串。可以查找文档内或输入域内特定的文本。

![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230420090148899-1397096734.png)

## 语法

### 普通字符

> g为修饰符，下一节会介绍

![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230419092639650-1088292809.png)
![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230419092700686-34967008.png)

> 符号|ASCII码|含义
> \n|10|换行
> \r|13|回车CR

> 在Windows中：'\r'回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖；'\n'换行，换到当前位置的下一行，而不会回到行首
> Unix系统里，每行结尾只有换行，即'\n'

### 非打印字符

![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230419094339749-2141012067.png)

### 特殊字符

> 匹配特殊字符需要转义

![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230419095142925-350082057.png)

### 限定符

> 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有\*或\+或?或{n}或{n,}或{n,m}共6种。

![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230419100010425-649405717.png)

> \*和\+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只要在它们的后面加上一个?就可以实现非贪婪或最小匹配。

### 定位符

> 定位符用于将正则表达式固定到行首或行尾/创建特殊的正则表达式(出现在一个单词内、在一个单词的开头或者一个单词的结尾)
> 定位符用来描述字符串或单词的边界，^和$分别指字符串的开始与结束，\b描述单词的前或后边界，\B表示非单词边界。

![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230419101409578-985594904.png)

> 不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如^*之类的表达式。
> /^Chapter [1-9][0-9]{0,1}$/匹配章节标题

![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230419103451745-1375577485.png)

### 选择

> 用圆括号()将所有选择项括起来，相邻的选择项之间用|分隔。
> ()表示捕获分组，()会把每个分组里的匹配的值保存起来，多个匹配值可以通过数字n来查看(n是一个数字，表示第n个捕获组的内容)。

![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230419110742034-375310717.png)
副作用：相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。(eg:/(?:[1-9])([a-z]+)/g)
其中?:是非捕获元之一，还有两个非捕获元是?=和?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。

![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230419110947557-1385347051.png)
![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230419111014363-36466621.png)

### 反向引用

对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从1开始，最多可存储99个捕获的子表达式。每个缓冲区都可以使用\n访问，其中n为一个标识特定缓冲区的一位或两位十进制数。
可以使用非捕获元字符?:、?=或?!来重写捕获，忽略对相关匹配的保存。

反向引用的最简单的、最有用的应用之一，是**提供查找文本中两个相同的相邻单词的匹配项的能力**。以下面的句子为例：
Is is the cost of of gasoline going up up?
上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：
var str = "Is is the cost of of gasoline going up up";
var patt1 = /\b([a-z]+) \1\b/igm;
document.write(str.match(patt1));
运行结果：Is is,of of,up up
![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230420090410174-708401869.png)

反向引用还可以将通用资源指示符(URI)分解为其组件。假定您想将URI分解为协议(ftp、http等等)、域地址和页/路径：
var str = "https://www.runoob.com:80/html/html-tutorial.html";
var patt1 = /(\w+):\\/\\/([\^/:]+)(:\d\*)?([^# ]\*)/;
arr = str.match(patt1);
for (var i = 0; i < arr.length ; i++) {
    document.write(arr[i]);
    document.write("<br>");
}
运行结果：
https://www.runoob.com:80/html/html-tutorial.html
https
www.runoob.com
:80
/html/html-tutorial.html
![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230419111852747-1492899587.png)

## 修饰符(标记)

标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。
标记不写在正则表达式里，标记位于表达式之外，格式如下：
/pattern/**flags**

![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230420090851875-1690975145.png)

## 元字符

![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230420091736723-1268745222.png)![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230420091806902-1601750451.png)![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230420091911139-570250374.png)![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230420091939744-590187845.png)![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230420092003409-95076539.png)

实例：

// 匹配邮箱的正则表达式
var str = "abcd test@runoob.com 1234";
var patt1 = /\b[\w.%+-]+@[\w.-]+\.[a-zA-Z]{2,6}\b/g;
document.write(str.match(patt1));

![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230420093251073-135755573.png)

## 运算符优先级

![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230420093417644-1821257701.png)

## 一些实例

![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230420094230921-987819511.png)
![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230420094251085-121895430.png)
![img](https://img2023.cnblogs.com/blog/2975286/202304/2975286-20230420094308983-1730922327.png)
