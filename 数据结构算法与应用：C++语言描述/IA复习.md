# Exam

简答题(<20)：言之有理，迭代/解递归方程/P、NP、NPC、NPH……
算法分析题(<20)：给伪代码/程序，分析其复杂度，递归树/代入法/主定理
算法设计题(70)

- 算法分析的基本概念
- 算法复杂度的分析
- 贪心 不保证最优解 改进：k优化…… 最优性证明：0/1、连续、替换……分析即可，不考归纳法证明
- 分治
- 动态规划
- 回溯
- 分支界限
- P、NP、NP-Compelete、NP-Hard

讲算法的每章至少考一道算法设计大题(题目里会要求用什么算法)

## 算法分析

> 算法的定义及作用(性能评价方法：解析√/测量)
> 算法空间复杂度(占用空间) $S(n)$ 复合变量(数组、链表、树和图等)/环境栈空间(函数调用)
> 算法时间复杂度(计算时间) $T(n)$ 操作计数/步计数
> 算法最好、最坏及平均情形下的复杂度
> 算法复杂度的渐进表示方法 $O、\Omega、\Theta$
> 递归算法的复杂度

解递归：迭代法/递归树/代入法/主定理

eg：归并排序$T(n) = 2T(n/2) + cn$

\*递归树：![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230309111436528-2081910665.png)

代入法：猜上界/下界，归纳法证明，求解常量

\*主定理：![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230309112545490-164964021.png)
![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230309113002724-351082718.png)
![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230309113014619-402876353.png)
![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230309113035969-1346513317.png)

## 贪心

> 优化原理与贪心算法的基本要素：贪心策略？
> 货箱装船问题：选择重量最小的货箱
> 0/1背包问题(NPH)：value最大/weight最小/value：weight最大 均不能保证得到最优解 **k优化算法**？选定k个再进行贪心 比较最后的总价值
> 连续背包问题：value：weight最大 贪心解即是最优解
> 哈夫曼编码问题：变长码(使用频率高的，短) 按权值构造哈夫曼树，合并最小的两项，递归(使用优先队列)
> 活动安排问题：递归找最早结束的，加入解中
> 拓扑排序：递归选择度为0的结点，加入解中(栈)
> 机器调度问题：尽可能使用旧的机器
> 单源最短路径问题：松弛操作？Dijkstra算法(非负单源最短路径，按最短路长度从小到大依次求解，最小优先队列)/Bellman-Ford算法(一般情况下单源最短路径，找有没有负环，对连接该结点的每条边进行松弛操作)
> 最小生成树问题：安全边？选择n-1条边使它们形成G的最小生成树。Prim算法(在与已在生成树中结点的邻边中，每次选择权值c(e)最小且与以前选择的边不构成cycle的边e)/Kruskal算法(在所有边中，每次选择权值c(e)最小且与以前选择的边不构成cycle的边e)

## 分治

> 递归概念及分治法基本思想：divide-conquer-combine 缩小问题规模易于求解/分解的子问题可合并成原问题的解/子问题相互独立(不独立用动态规划)
> ？矩阵乘法(分块没用，用Strassen算法)：令递归树稍微不那么茂盛一点——只递归进行7次而不是8次矩阵的乘法。<https://www.cnblogs.com/kirin-dev/p/Introduction-to-Algorithms_Chapter-4.html#tid-ebkMHR>
> 棋盘覆盖：n=4^k(k = 0, 1, 2……找规律)t(n)=4t(n/4)+c, logba=1,case 1:ε=0.5,t(n)=Θ(n)
> 归并排序![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230309133741127-1263291550.png)
> 快速排序：pivot基准，左边小于pivot，右边大于pivot，递归![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230309133921861-143325694.png)
> 选择问题：找出第k小的元素(先排序，再取出O(nlogn))
> ？最大最小问题:![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230309134353294-259910034.png)

## 动态规划

> 动态规划的基本原理：在各个不同大小的子问题的优化值之间建立递归关系并求解(利用优化原理,使用枚举法建立不同长度子问题的优化值之间的递归关系——动态规划方程) **回溯得到优化解**
> 0/1背包问题：无论优化解是否放物品1，相对剩余背包容量，优化解对物品2,…,n的放法也是优化解：f(1,c)=max{不放1：f(2,c), 放1：f(2,c-w1)+p1}![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310085605735-1079178269.png)
> 0/1背包问题的递归实现、迭代实现及元组法实现方法![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310094908395-505285338.png)![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310095309627-160889862.png)![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310095456393-638962065.png)![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310095731905-2063826450.png)元组法将函数f(i, y)的跳跃点以元组(y, f(i, y))形式存储于一个线性表P(i)中：![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310100554199-213927579.png)![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310100602791-2022095509.png)
> 矩阵乘法链：用M(i, j)表示链Mi×…,×Mj(i≤j)的乘积.假设优
化的矩阵链乘法顺序最后计算乘积M(i, k)×M(k+1,j).则子链M(i,k)和M(k+1,j)也是优化的 c(i,j)=min{c(i,k)+c(k+1,j)+ri\*rk+1\*rj+1} 求c(1,矩阵数) 设q=5和r=(10,5,1,10,2,10)
> 最短路径问题：最短路的子路径也是最短路：c(i)=min{c(j)+cost(i, j)}
> All-Pair最短路问题：求每对点间的最短路 定义c(i,j,k)为i到j的中间节点编号不超过k的最短路长度 (i到j的中间节点编号不超过k的最短路上, 或包含节点k或不包括节点k) c(i,j,k)=min{c(i, j, k-1), c(i, k, k-1)+c(k, j, k-1)}

## 回溯

> 回溯法: 加限界的深度优先展开状态空间树
> 解空间表示及回溯法的算法框架：假定问题的解能用n元组(X1,…,Xn)表示，其中Xi取自某个有穷集Si。这些n-元组构成的集合称为问题的解空间。假设|Si|=mi，则解空间的大小为m=m1m2…mn。![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310185629261-578237104.png)
> 子集和数：求元素之和等于target的子集 放入/不放入 限界条件：目前条件下加上剩下的数小于target
> n皇后问题：![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310184522789-30750175.png)
> 货箱装船：装/不装 限界条件：总重量大于载重//有两艘船，是否能将货箱全装走？最大化第一艘船的装船量，剩下的货箱如果可以装入第二艘船，则找到一个可行解。
> 0/1背包问题：装/不装 限界条件：总重量大于载重/目前条件下剩下部分按连续背包问题算时总价值小于等于bestp
> 最大完备子图问题(NPH)：最大连通子图 最大独立集(最大的无边相连的顶点集合) G的连通子图对应其补图的独立集 限界条件：当前集团的顶点数加剩余顶点数小于等于bestn
> 旅行商问题(可用dp)：求找出一条最小成本的周游路线 限界条件：当前开销大于bestc

## 分支限界

> 分支限界法：广度优先展开状态空间树 维护活结点表(FIFO、LIFO、优先队列)
> 分支限界的基本思想：![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310204330400-1480514608.png)![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310204234824-92056401.png)
> 作业调度问题：每个作业i对应一个三元组(pi,di,ti)。pi罚款额；di截止期；ti花费时间，求可行作业子集使得罚款额最小![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310204931524-1170299254.png)![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310204905344-1070435914.png)![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310205009116-1753472178.png)![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310205031140-1412403220.png)
> 0/1背包问题(见作业)

## NP完全性理论

> 问题是“难”还是“易”?一般来说，我们认为在多项式时间内可解的问题是易处理的问题，在超多项式时间内解决的问题，比如指数时间，是不易处理的问题。
> 类P问题、类NP问题、NP难问题及NP完全问题

多项式时间算法简称为P(Polynomial)问题，即图灵机上多项式时间可解的问题

NP(Nondeterministic Polynomial)类问题(非确定性多项式时间算法问题)不能确定是否能在多项式时间内找到答案，但是可以在多项式时间内验证答案是否正确

P问题(容易找到)；NP问题(容易检查) P属于NP

NPC(NP-Complete)问题：1. 是NP问题2. 所有NP问题在多项式时间内都能约化到它。

NPH(NP-hard)问题：所有NP问题在多项式时间内都能约化到它//所有的NPC问题都可以在多项式时间内转化为它。

![img](https://img2023.cnblogs.com/blog/2975286/202303/2975286-20230310210548177-62202549.png)
